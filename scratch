1. Elegant asynchrony
2. Functional
3. Struct composition over inheritence
4. Hybrid typing
4. State represented as deltas rather than "stateless"

*****************

// Types and other keywords
let?
const
immut

define
macro
import
exception

if
for
while
continue
break
fn
component
new
free
print
bind
fn
gn
as
yield
defer
exception
each
apply
delta

Int (Int32)
Char (Int8)
Short (Int16)
Long (Int64)
BigInt (Int128)
Unsigned 8 16 32 64 128

Float (Float32)
Minifloat (Float8)
Half (Float16)
Double (Float64)
Quadruple (Float128)
Octuple Float(256)

Rune (Int32)
String (Rune[])
Bool (Char)
Byte (Char)

// Different colors for different types
foo:int -> red foo
foo:string -> blue foo

-> blue foo and red foo are totally different
PROBLEMS: big programs with hundreds or thousands of custom types will run out of colors quickly
Need to remember what color goes where

// variables with let
let varName 'variable'

// constants with const
const constName 'const'

typegroup - a set of types, like a more restricted void*

typegroup Number32: Int32 Float32
typegroup Number64: Int64 Float64
typegroup Number: Number32 Number64

interface - a set of functions. implicitly implement the interface if you define those functions on a type

interface Printable
  // First arg will always be self
  fn ToString -> String // implies ToString . Printable -> String

interface Solid
  fn CalculateVolume -> Int
  fn Scale . Int -> Solid
  fn Project . Surface -> Surface

typegroups (schemata) - like an interface, but with data instead of funcs
schema address
  has
    street_number
    street_name
    postal_code
  optional
    state
    city
    country
    apartment
  forbidden
    planet
    galaxy

Hybrid typing
let myConst1 10 // Implicitly typed as an Int32
let myConst2 10:Float32 // Explicitly typed as a Float32

let myAddr
  street_number "1410"
  street_name   "fake st"
  postal_code   "12321"
  country       Countries/USA


// explicit typing
let varNameExplicit 'explicit' as String

// Macros (preprocessor directives)
macro printl (foo)
  print foo:Type + ' ' + foo:VarName + ': ' + foo // could also be + foo:Value

macro printl? (foo)
  print? foo:Type + ' ' + foo:VarName + ': ' + foo // could also be + foo:Value

snippets vs macros?

snippet check_auth -> @responseType
  if !authserv/isValidUser . session/user
    #/setStatus . 403
    #/addErrors . "Invalid user"
    ~ = "Invalid User"
  elif !authserv/hasPermission . session permission
    #/setStatus . 403
    ~ = "Insufficient permissions"
  else
    #/setStatus . 200

fn test_snippets . session -> response
  pemission = "admin"
  check_auth // uses the defined local var names!

  #/setNote . "Adding onto the output generated by the macro!"


// Preprocessor configuration goes in a define block
define
  // Like python - whitespace matters. By default a tab is 4 spaces. You can change it here though
  SpacesPerTab 2
  LintFile __RootDir + '/cfg/.lint'
  EndlAfterPrint true


// File importing happens in an import block
import [
  http

// call a function with fnName . args
myFunction . arg1 arg2 arg3

// access a property of an object with :
print myObject:member1

// Named component
component Session
  Token  String
  UID    String
  Expiry Int

// Instantiate a named component
let sess Session
  Token  'abc123'
  UID    '789xyz'
  Expiry 0

deltas as atomic types
  -track a state-change

apply . state [deltas]
  returns a copy of a state with deltas applied
  deltas are cascading
  * need a way to handle generating deltas concurrently, then applying all
  * need this to be efficient

therefore when you do something like
const map1 {
  'foo' 'bar'

alias mapdelta {
  'foo' 'bar2'

const map2 (map/set . map1 mapdelta)

really you're doing
const map2 (apply . map1 (map/__getSetDelta . map1 mapdelta))

// TODO: What was I thinking here? void cant have return
let firstDelta Session/delta {
  Token (t) -> void { # = t[0] }
}

let secondDelta Session.delta {
  Token (t) -> void {# = string/ToUpper . t}
}

apply . sess (firstDelta secondDelta)

compress deltas? any given byte / word has multiple names (varname + deltaid)
when you stop caring about history before a certain point (or between two points), ability to squash?

let num1 100
num1 = 200

// deltas
{
  [
    0293-0291-10293843-092342-092133
    3920-8319-43789103-832741-883921
  ]

  num1.0293-0291-10293843-092342-092133: 100
  num1.3920-8319-43789103-832741-883921: 200
}


// aliasing, much like a macro, replaces itself inline before compilation
alias do_funcs func1.func2.func3.func4.func5
print do_funcs . myFoo1

// preprocessor spits out this:
print func1.func2.func3.func4.func5 . myFoo1

// in all languages, nested function calls suck
func1(1, b, func2(c, func3(a), d), func4(100))
// so you store stuff in variables
t1 = func3(a)
v1 = func2(c, t1, d)
v2 = func4(100)
func1(1, b, v1, v2)

// compiler may optimize these away, but why not allow the user to explicitly tell it to?
alias t1 func3 . a
alias v1 func2 . c t1 d
alias v2 func4 . 100
func1 . 1 b v1 v2

// compose functions
fn lowercase . character -> Char
  // Maybe the way chars are handled, you dont need to cast anything
  if 65 <= character as Int8 <= 90
    # = (character + 35) as Char

fn first . string -> Char
  # = string[0]

compose (first lowercase) as lower_first
// alias lower_first first | lower // is this better?

// preprocess spits out
fn lower_first . string -> // args are the same as to first
  // # is replaced with t1
  let t1 string[0]

  // lowercase's args are replaced with t1 ..
  if 65 <= t1 <= 90
    # = t1 + 35

// Throw preprocessor error if a function takes different args than the previous
//   function returns


// Anonymous component
const headers
  Auth   'Bearer abc123'
  Accept '*'


// System
system PhysicsSystem
  Transform
  Displacement
  Colliders

fn PhysicsSystem/EachTick . GlobalTimerValue -> void
  # Do physics stuff

// Block on an async function
const url 'http://www.example.com/check-logged-in'
let loggedIn ..http/Get . url headers

// Run an async function without blocking
const res1 doSomethingComplicated . data1..
const res2 doSomethingComplicated . data2..
const res3 doSomethingComplicated . data3..

// accessing a promise might throw an exception if you don't await it
print proc1

// Block on a previously run async function
..proc1 proc2 proc3

// i/o

// Use print? to not print nil
const a 'Hello'
print a // Hello
print? a // Hello

const b nil as String
print b // nil
print? b // no output


// if myVar isn't a primitive, calls toString. If no toString, throw exception
print myVar

// iteration
const arr ['a' 'b' 'c' 'd']


// Implied variables i (index) and item (element)
each . arr (fn -> void
  print i item

// i and item are const
each . arr (fn -> void
  item = to_lowercase . item // compiler error


// how would you implement your own each?
fn each . arr (fn . i? item? _ -> void
  for i = 0 to (length . arr)
    func . i? item? _

// You can iterate multiple dimensions easily

for i = 5 to 10
  print i // 5 6 7 8 9

for i = 5 thru 10
  print i // 5 6 7 8 9 10

for i = 5 exto 10
  print i // 6 7 8 9

for i = 5 exthru 10
  print i // 6 7 8 9 10

const arr ['a' b' 'c' 'd' 'e']
for i = length . arr exthru 0
  print arr[i] // e d c b a

for x y = 0 0 to width height
  print x y ',' // 0 0, 0 1, 0 2, ... , 1 0, 1 1, 1 2 ...

//loops dont need to declare an index variable
for 0 to 5
  print 'hi'

// functions that only take a single callback as their args can optionally omit
//  a pair of parens
each . arr (fn . n str -> void
  // Explicit variables n (index) and str (element)
  print n str

// Function descriptors
@<params> <type>
@scope <function>:<type>
  -closure,
@decorated <function>
@preserve

preserve: used to preserve the function name for calling


// Declare an async function
// Question: do functions need to be declared as async or can any function be called asynchronously?
@[a b c] Int
fn myFoo.. (fn . a b c -> Int
  let ab a+b
  let bc b+c
  # = ab + bc !


// Declare a sync function
@a Bool
@b String
// @c Any // this is implied

// Maybe declare like this?
fn myCond (fn . a b c -> Any
  if a
    # = b !
  if b
    # = a !
  else
    # = c !

@a Int
@b String[]
fn myBar . a b -> void
  each . b (fn -> void
    if index < a
      print item

// Run a sync function on a new thread
myCond(true 'foo' 'bar')..

// Run code synchronously on a new thread
myLabel
  print 'This block is...'
  myCond . true 'str' 9
  print '...still synchronous!'
..

// Wait for that code block to finish
..myLabel
print 'now myLabel is done running'

// Variadic args with _
// Automatically return # if no return is specified (compiler warning if you return # without modifying it)
@ _ String
fn strcat . _ -> String
  each . _ (fn -> String
    # += item


// Return early by ending a line with !
fn find . el arr -> Int
  each . arr (fn -> void
    if item == el
      # = i !

  # = -1

// You can end any line like this
fn printn . el arr ->
  each . arr (fn -> void
    if item == el
      print i !

// Keyword args with _*
fn printData . _* -> void
  printl? _*:Name
  printl? _*:Date
  printl? _*:Age
  printl? _*:Job
  printl? _*:Salary

// Better to still explicitly return #
fn bad . a -> String
  if a
    # = 'A is true' !

fn bad . a -> String
  if a
    # = 'A is true' !
  else
    # !

@[a b] Int
fn euclid . a b -> Int
  if b > a
    a, b = b, a
  while b != 0
    b, a = a%b, b

// Loop through the properties of a and print them
print a:*


// Channels are really useful
let msg: Chan(String)

@file File
@msgChan Chan(String)
fn stream . file msgChan -> Bool
  let start 0
  const fileSize (fs/filesize . file)
  while start < fileSize
    let end start + 10000
    if end > fileSize
      end = fileSize
    http/sendfile . fs/readstream . file start end
    msgChan <- // Wait for a response that they got the chunk

// Access array elements
const arr ['d' 'e' 'h' 'l'  'o' 'r' 'w' '!' '!' '\n' ' ' ',']

// NOTE: + operator automatically calls map
let str ''
str += arr[2] + arr[1] + arr[3]*2 + arr[4]
str += arr[-1 to -2]
str += arr[6] + arr[4 to 5] + arr[3] + arr[0]
print str // hello world!!\n

print fp/map (+ arr) // identical to print '' + arr

// function binding
fn sum . a b -> Int
  # = a + b !

bind sum5 sum(5 ?)

sum5(10) // 15

@all Int
fn myFunc . a b c d e -> Int
  # = a + b - c * d / e !

// You can always name your args in a bind (not necessary though)
@all Int
bind negReciprocal myFunc(a:0 b:0 c:? d:1 e:?)

negReciprocal . 2 1 // -0.5

// Pointers
let $varName as Int // Declare an int pointer
const $constName as int // Declare a const pointer (cannot assign it to a new memory address)
immut $immutName as int // Declare an immutable pointer (const and read-only)

// Same but on the heap
new let $varHeap as Int
new const $constHeap as Int
new immut $immutHeap as Int

let $ptr 10
print $ptr // print the address
print ptr // print the value

// Free the memory
free $varHeap
free $constHeap
free $immutHeap

// Defer until end of function
fn makeIntMemory (n)
  new let $ints as Int[n]
  defer free $ints
  each . n ()
    print $ints[i]

// Exceptions are stored in ~. Once ~ is set, function exits
fn divide . a b -> Int
  if b == 0
    ~ = 'DivideByZeroException'
  else
    # = a / b

print divide . 1 0

if ~
  print 'You can't divide by zero'


// is ~ thread-scoped? how would that work? otherwise need something like

try
  print divide . 1 0
else
  print 'You can't divide by zero'

//or

// catch always checks ~ from the previous expression
// with nested function calls, this only pushes the problem down 1 level (no bueno)
print divide . 1 0
catch
  print 'You can't divide by zero'


// String formatting
print "Double quoted strings have %1 %2" with 'formatting', 'capabilities'

let myVar 'name'
print "You can $myVar your formatting %1" with 'variables'

let varStore
  foo 'store'
  bar 'map'

print "You can also %foo your variables in a %bar" with varStore


let overwrite 'this will not be printed'
let varStore
  overwrite 'this will be printed'


print "%overwrite" with varStore

// Templating (code generation)
const myTemplate `
  @preserve
  @all Int
  fn %1 . a b c d e -> Int
    # = (a + b + c + d) \% e !
`

eval . myTemplate with 'myFunctionName'
print myFunctionName . 1 2 3 4 5

// Or to be more programmatic
let fnName 'myFunctionName'
eval . myTemplate with fnName // eval used to call a function by pointer
call . fnName 1 2 3 4 5 // call used to call a function by string

to, exto, thru, exthru: range filler
as: assignment
with: formatting / templates

<fn>.. async call
..<fn> blocking call
@ explicit typing
* wildcard
# output
~ error
? unbound arg, implied arg
$ pointer
& member function arg
| pipe
% str formatter, str formatting var name
&& binary and
|| binary or
// comment
-> map
_ variadic args
` template bounds
: subproperty access
. function call
, var swapping
\ escape as str / char

+ - * / ^ %


this keyword
  -refers to the actual function object

ctx keyword
  -refers to the context of the function

/*
// Style? Want to enforce it
// Need parens around nested function calls UNLESS only arg is a function call
const new_arr arr:each -> [String]
  append . # first_letter . to_lowercase . item
  // append(#, first_letter(to_lowercase(item)))
  // (append # (first_letter (to_lowercase item)))

  // parens after # because the whole of it is an arg
  // no parens around to_lowercase call because it is the only arg of first_letter
  append . # (first_letter . to_lowercase . item)

  // this works too
  append . # first_letter.to_lowercase.item
  // alternately
  alias lower_first first_letter.to_lowercase.item
  append . # lower_first.item

  // this is funky, i kinda like it though
  append . #
           first_n_letters 2
                           to_lowercase . item

*/

/*
  Problems:
    1. compiling is probably going to be slow
    2. heavily reliant on code highlighting to understand what's going on
*/
